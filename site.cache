[{'category': '', 'index': False, 'subpages': [], 'target': u'index.html', 'title': 'embellish - a lightweight static website generator', 'url': u'index.html', 'checksum': "vS\xfa8\x80\xa0D\x9f\x8c\x01.\x1fq'>-", 'rel_site_url': '.', 'excerpt': u'Embellish a lightweight static website generator There are many static website generators out there, but most of them are quite opionated: they demand your posts be put in this directory and your posts ordered in that way, and they often include some tricky custom-defined formats. Static websites are really quite ...', 'modified': 1393289010.0, 'filename': '/Users/bosco/Dropbox/public/embellish-gh/index.txt', 'content': u'<h1>Embellish</h1>\n<blockquote>\n<p><em>a lightweight static website generator</em></p>\n</blockquote>\n<p>There are many static website generators out there, but most of them are quite opionated: they demand your posts be put in this directory and your posts ordered in that way, and they often include some tricky custom-defined formats.</p>\n<p>Static websites are really quite simple. They\'re just a bunch of HTML files in a directory. A static website generator simply transforms text files into HTML files, and includes a few goodies like stylesheets and javascript modules.</p>\n<p><code>embellish</code> is a lightweight generator, that can build a website from any directory, transforming any text files it finds into HTML, allowing you to organically grow your website. It\'s also very small, and quite easy to modify. </p>\n<p>As <code>embellish</code> is designed around the Python ecosystem, it carefully uses standard Python-like indented-text formats, that have been well-tested, namely:</p>\n<ul>\n<li>markdown for text</li>\n<li>YAML for configuration </li>\n<li>HAML/JINJA2 for HTML templating</li>\n<li>coffeescript for javascript </li>\n<li>indented-SASS for CSS stylesheets</li>\n<li>flask for running the local webserver </li>\n</ul>\n<h2>Example Websites Built with Embellish</h2>\n<ul>\n<li><a href="http://boscoh.com">Bosco Ho\'s Emporium of Words</a> - my personal website</li>\n<li><a href="http://boscoh.github.io/supplescroll">supplescroll</a> - a document decorator used to build this page</li>\n<li><a href="http://boscoh.com/geneparade/human/">the human gene parade</a> - an interactive genome browser</li>\n</ul>\n<h2>Quick &amp; Dirty Websites</h2>\n<p>Other generators dictate your website to be structured their way. <code>embellish</code> does not. </p>\n<p>Go to a directory with a <code>markdown</code> file (e.g. the <code>embellish</code> directory):</p>\n<div class="codehilite"><pre>&gt; embellish -m .\n</pre></div>\n\n\n<p>Boom! </p>\n<p><code>readme.html</code> is generated and opened in a browser.</p>\n<p>Now edit <code>readme.txt</code>, save, and refresh the browser.</p>\n<h2>Installation</h2>\n<p>The project is hosted at <a href="https://github.com/boscoh/embellish">github</a>.</p>\n<p>Have <code>python</code> and <code>pip</code>? Then:</p>\n<div class="codehilite"><pre>  &gt; pip install embellish\n</pre></div>\n\n\n<p>Or install manually using the <a href="https://github.com/boscoh/embellish/archive/master.zip">zip file</a>:</p>\n<div class="codehilite"><pre>&gt; python setup.py install\n</pre></div>\n\n\n<p>All the following examples can be found in the <code>examples</code> directory of the zip file.</p>\n<p>Dependencies (which should have been installed by <code>pip</code>): </p>\n<ul>\n<li>markdown</li>\n<li>pyyaml</li>\n<li>hamlpy</li>\n<li>jinja2</li>\n<li>jinja2_hamlpy</li>\n<li>flask</li>\n<li>dateutil</li>\n<li>sassin</li>\n</ul>\n<h2>Blog with Categories</h2>\n<p>Any litmus test for a static website generator is to make a blog. Here\'s a quick guide using <code>embellish</code> where <code>markdown</code> is used for the text, <code>YAML</code> for metadata, and <code>haml</code> to write the HTML.</p>\n<p><code>embellish</code> will recognize files with extensions <code>.txt</code>, <code>.md</code>, <code>.mkd</code> and <code>.markdown</code> as post/article pages.</p>\n<h3>Article page</h3>\n<p>The structure of a content page has three sections separated by <code>---</code>:</p>\n<ol>\n<li>header</li>\n<li>excerpt</li>\n<li>markdown text</li>\n</ol>\n<p>such as in <code>post.mkd</code> <a href="#fig-post"></a>.</p>\n<div id="fig-post">\n  <code>post.mkd</code> - example of a Markdown Post\n  <pre class="codehilite">\ntitle: The Title of this Post\ntemplate: post.haml\n---\nExcerpt of post\n---\n# Great Post in Markdown\n\n## Markdown Sub-headers!\n\nThis is the _body_ of the text \nwritten in markdown\n  </pre>\n</div>\n\n<p>Both the header and the excerpt are optional. If only two sections are given, then it\'s assumed that it\'s a header and body, and an excerpt is auto-generated.</p>\n<p><code>embellish</code> reads the header as <a href="https://github.com/Animosity/CraftIRC/wiki/Complete-idiot\'s-introduction-to-yaml">YAML</a> metadata. There are a few fields used by <code>embellish</code> but you can add anything you want. This metadata will be made available to you in the template as a dictionary called <code>page</code>.</p>\n<p>To generate an HTML page from this article post, a template is required. In this case, the template referred to in the header is <code>post.haml</code>. If no template is given, a default one is used that is located in the embllish directory under <code>defaults/default.haml</code>.</p>\n<h3>Templates and Style Sheets</h3>\n<p>Templates are used to generate HTML files from text files and their attendant header information.</p>\n<p><code>embellish</code> uses the <a href="https://github.com/jessemiller/HamlPy/blob/master/reference.md">jinja2-haml</a> format for templates. A simple example is <code>post.haml</code> <a href="#fig-template"></a>, which was referred in <code>post.txt</code> above.</p>\n<div id="fig-template"> \n  <code>post.haml</code> - example of a simple HAML template to generate an article HTML\n  <pre class="codehilite">\n%head\n  %link{href:\'styles.css\', rel:\'stylesheet\'}\n%body\n  .title\n    {{ page.title }}\n  .nav\n    category: \n    {{ page.category }} &#183;\n    published: \n    {{ page.date.strftime("%d %b %Y") }}\n  %hr\n  {{ page.content }}\n  </pre>\n</div>\n\n<p>For details on how templates work in <code>embellish</code>, see the Template Guide below.</p>\n<p>Notice that there is a link to a style sheet <code>styles.css</code> <a href="#fig-template"></a>. Now, you could simply creat your own <code>styles.css</code> and put it in the directory, but I strongly recommend you to write <a href="https://github.com/boscoh/sassin">SASS</a> style sheets such as <code>styles.sass</code> <a href="#fig-sass"></a>, which will be automatically compiled into <code>styles.css</code> for you.</p>\n<div id="fig-sass"> \n  <code>style.sass</code> - a SASS file to generate <code>style.css</code>\n  <pre class="codehilite">\nbody\n  background-color: #FFF\n  font-family: Helvetica\n  width: 450px\n  margin: 40px auto\n.title\n  text-transform: uppercase\n  font-weight: 900\n  font-size: 18px\n  letter-spacing: 0.1em\n.nav\n  font-style: italic\n  font-size: 12px\n  </pre>\n</div>\n\n<p>With the post, the template, and the style sheet done, we are now ready to make the blog:</p>\n<div class="codehilite"><pre>&gt; embellish .\n</pre></div>\n\n\n<p>Open <code>index.html</code> and <code>archive.html</code> in your browser.</p>\n<h3>Index Pages</h3>\n<p>To really get the blog going, though, we will need to build an index page. First, we create a text file that will generate an index of posts <code>index.mkd</code> <a href="#fig-index-mkd"></a>.</p>\n<div id="fig-index-mkd"> <code>index.mkd</code> - example of a markdown file that generates a blog index file\n<pre class="codehilite">\ntemplate: index.haml\nindex: True\nsort_key: date\nsort_reverse: True\nmax_subpages: 5\ntitle: Blog Posts\n---\nShort excerpt of this post.\n---\nSome words to describe the following list of \nposts that are arranged in reverse chronological \norder.\n</pre>\n</div>\n\n<p>In the header of the post, the key flag is:</p>\n<div class="codehilite"><pre>index: True\n</pre></div>\n\n\n<p>which tells <code>embellish</code> to send a list of posts into the template during compilation of the HTML file. Since in this case, no <code>category</code> was given, all the posts found by <code>embellish</code> will be used.</p>\n<p>The posts will be sorted by date as indicated by:</p>\n<div class="codehilite"><pre>sort_key: date\n</pre></div>\n\n\n<p>Other fields could have been used, but let\'s start with date. We\'d also like to do it in reverse order as fits blogging convention:</p>\n<div class="codehilite"><pre>sort_reverse: True\n</pre></div>\n\n\n<p>And we don\'t want too many posts, so</p>\n<div class="codehilite"><pre>max_subpages: 5\n</pre></div>\n\n\n<h3>Templating Index Pages</h3>\n<p>Okay now the text file is done, let\'s make the template for an index file <code>index.haml</code> <a href="#fig-index-haml"></a>.</p>\n<div id="fig-index-haml"> <code>index.haml</code> - example of a HAML template that generates the HTML code for an index markdown file\n<pre class="codehilite">\n%head\n  %link{href:\'styles.css\', rel:\'stylesheet\'}\n%body\n  .title\n    {{ page.title }}\n  {{ page.content }}\n  %ul  \n    - for subpage in page.subpages:\n      %li\n        %b\n          %a{href:"{{ page.rel_site_url }}/{{ subpage.url }}"} \n            {{ subpage.title }}\n        %br\n        %i {{ subpage.excerpt }}\n        %br\n       .nav\n          - if subpage[\'category\']:\n            category: {{ subpage.category }}\n            %br\n          date: {{ subpage.date.strftime("%d %b %Y") }}    \n        %br\n        %br\n</pre>\n</div>\n\n<p>How it works is that during compilation, <code>embellish</code> will package all the information for the page into a dictionary <code>page</code> and send it into the template. As well another dictionary <code>site</code> will also be sent that includes the site configuration finformation. These will be described in detail below in the Templating Guide.</p>\n<p>The header of the template is pretty similar to <code>post.haml</code> <a href="#fig-template"></a> above, with the big difference in that <code>index.haml</code> <a href="#fig-index-haml"></a> can handle a special field called <code>page.subpages</code>. </p>\n<p><code>page.subpages</code> holds a list of all the pages found by <code>embellish</code> that belong to this index page. If a <code>category</code> was given, then only pages with the same <code>category</code> are found in the list. And since no <code>category</code> was given here, all pages are given.</p>\n<p>To handle the display of all the <code>page.subpages</code>, there is a jinja2-haml loop:</p>\n<div class="codehilite"><pre>- for subpage in page.subpages:\n    {{ subpage.title }}\n    {{ subpage.excerpt }}\n</pre></div>\n\n\n<p>Note: it\'s important you use <code>subpage</code> as the looping variable, as <code>page</code> would otherwise clash with the main <code>page</code> dictionary.</p>\n<p>Now if you did not provide an excerpt, an automatic 50 word excerpt will be generated for you from the text.</p>\n<p>You might have noticed that there is no pagination. I detest pagination, so did not implement it. Just put them all in one page. Please.</p>\n<h3>Referring to URLs</h3>\n<p>It\'s important to get the URL\'s right to show up in the template.</p>\n<p>First we need the site URL, and there are two ways to get it:</p>\n<ol>\n<li>The site\'s absolute URL, which is <code>{{ site.url }}</code></li>\n<li>The site\'s relative URL which depends on the location of the page in question <code>{{ page.rel_site_url }}</code></li>\n</ol>\n<p>The URL of a page thus combines the site\'s URL with the page\'s URL. </p>\n<p>If you want the absolute URL, you do this:</p>\n<div class="codehilite"><pre>{{ site.url }}/{{ page.url }}\n</pre></div>\n\n\n<p>For the relative URL of a page, which is more flexible, but more prone to breaking during deployment :</p>\n<div class="codehilite"><pre>{{ page.rel_site_url }}/{{ page.url }}\n</pre></div>\n\n\n<p>In <code>index.haml</code> <a href="#fig-index-haml"></a>, relative links are used for the <code>subpage</code> in the looping through the collected posts, so the link is:</p>\n<div class="codehilite"><pre>{{ subpage.rel_site_url }}/{{ subpage.url }}\n</pre></div>\n\n\n<h3>Archiving With Categories</h3>\n<p>Now with blog posts, you might want to archive posts under different categories. </p>\n<p>Let\'s say you have a post about vampires <code>vampire.mkd</code> <a href="#fig-vampire-post"></a>. You give it a category in the header by:</p>\n<div class="codehilite"><pre>category: vampire\n</pre></div>\n\n\n<div id="fig-vampire-post"> <code>vampire.mkd</code> - a post with a category of vampire.\n<pre class="codehilite">\ntitle: The Vampire Post\ntemplate: post.haml\ncategory: vampire\n---\nExcerpt of vampire post\n---\n# This is Vampire Post\n\n## There\'s Vampire as Category!\n\nThis is also in __markdown__.\n</pre>\n</div>\n\n<div id="fig-archive-index"> <code>archive.mkd</code> - a post with a category of vampire.\n<pre class="codehilite">\ntemplate: index.haml\nindex: True\nsort_key: date\ncategory: vampire\nsort_reverse: True\ntitle: Archive of Posts about Vampires\n---\n</pre>\n</div>\n\n<p>Then, to collect all your vampire posts in an archive, you can create an index file <code>archive.mkd</code> <a href="#fig-archive-index"></a>, where the only difference from <code>index.mkd</code> <a href="#fig-index-mkd"></a>, is that a category is given:</p>\n<div class="codehilite"><pre>category: vampire\n</pre></div>\n\n\n<p>And then you run:</p>\n<div class="codehilite"><pre>&gt; embellish .\n</pre></div>\n\n\n<p>Which will generate an archive page for vampir posts <code>archive.html</code>.</p>\n<h2>Larger Websites</h2>\n<h3>Configuration Files</h3>\n<p>Obviously for a more complicated website, you want to separate your content, templates, assets, and output into different directories.</p>\n<p>To tell <code>embellish</code> where the directories are, you create a configuration file in the YAML format, such as <code>site.yaml</code> <a href="#fig-config"></a>:</p>\n<div id="fig-config"> <code>site.yaml</code> a YAML configuration file for a larger website\n<pre class="codehilite">\nurl: http://boscoh.com # if empty then use relative urls\ncontent_dir: content  # look for markdown files\ntemplate_dir: templates  # look for templates\noutput_dir: site  # generated files and static files put here\nmedia_dir: media  # files to be correctly directly into the output file\next: .html\n</pre>\n</div>\n\n<p>To whit:</p>\n<ul>\n<li><code>url</code>: the hard-coded URL of your website. If given, this is available in any templates you make as <code>site.url</code>.</li>\n<li><code>content_dir</code>: the directory where you put all your posts and index files.</li>\n<li><code>template_dir</code>: for holding templates</li>\n<li><code>media_dir</code>: your supporting files - javascript, css style sheets, images, movies, etc. These will be copied directly into the <code>output_dir</code></li>\n<li><code>output_dir</code>: the directory where all compiled contents and contents of <code>media_dir</code> are put</li>\n<li><code>ext</code>: the extension for the html files, typically <code>.html</code> or <code>.htm</code></li>\n</ul>\n<p>To run <code>embellish</code> against this configuration file:</p>\n<div class="codehilite"><pre>embellish site.yaml\n</pre></div>\n\n\n<p>And the result will be in the <code>output_dir</code>.</p>\n<p>Note: when using <code>embellish</code> with a directory as the argument, such as:</p>\n<div class="codehilite"><pre> &gt; embellish .\n</pre></div>\n\n\n<p>Internally, <code>embellish</code> sets these fields in <code>site</code> - <code>content_dir</code>, <code>template_dir</code>, <code>media_dir</code>, <code>output_dir</code> - to the current directory. <code>embellish</code> will skip the copying of files, and thus the website is made in place!</p>\n<h3>Recursive Directory Processing</h3>\n<p>Since <code>embellish</code> is meant to be a quick-and-dirty website generator, the default is to search only in the directory specified for content files. </p>\n<p>This avoids accidentally telling <code>embellish</code> to search through a very large forest of subdirectories.</p>\n<p>But you can tell <code>embellish</code> to exhaustively process all subdirectories with the <code>-r</code> option:</p>\n<div class="codehilite"><pre>&gt; embellish -r .\n</pre></div>\n\n\n<h3>A Bit of Media Processing</h3>\n<p>Another useful thing that <code>embellish</code> does during the copying from  the <code>media_dir</code> files, some extra file processing is done:</p>\n<ul>\n<li><code>.sass</code> files are compiled to <code>.css</code> style sheets</li>\n<li><code>.scss</code> files are compiled to <code>.css</code> style sheets</li>\n<li>straight <code>.haml</code> with no template tags are compiled into <code>.html</code> files</li>\n<li><code>.coffee</code> files are compiled to <code>.js</code> javascript files</li>\n</ul>\n<p>So potentially, your directory could just consist of <code>.haml</code> files and</p>\n<div class="codehilite"><pre>&gt; embellish .\n</pre></div>\n\n\n<p>will make a nice website consisting of compiled <code>.html</code> files.</p>\n<h2>Debugging Websites</h2>\n<h3>Local Webserver</h3>\n<p>To iterate designs quickly, it\'s important you see the compiled websites easily. Like other static website generators, <code>embellish</code> provides a local webserver to do this.</p>\n<p>Why? </p>\n<p>Opening local <code>.html</code> pages through a browser is a crippled process. Browsers can\'t figure out <code>index.html</code> files from directory names and relative URL\'s get all messed up. These are features that are typically available through your remote webserver, your ultimate destination.</p>\n<p>So, if you test relative URLs, it\'s a nightmare. If you use test absolute URLs, it\'s also a nightmare.</p>\n<p>To help with that, <code>embellish</code> comes with a local web-server written in <code>flask</code> that emulates common Apache <code>.htaccess</code> features such as:</p>\n<ul>\n<li>adding trailing <code>/</code> to directories</li>\n<li>processing implied <code>index.html</code> in directories</li>\n<li>adding implied <code>.html</code> to clean urls</li>\n</ul>\n<p>To run the <code>embellish</code> local web-server:</p>\n<div class="codehilite"><pre>embellish -m .\n</pre></div>\n\n\n<p>Or if you have a configuration file:</p>\n<div class="codehilite"><pre>embellish -m site.yaml\n</pre></div>\n\n\n<p>The local web-server will pick a random port so that you can run different servers for different websites at the same time.</p>\n<p>As well the <code>embellish</code> server:</p>\n<ul>\n<li>monitors modfications in directories </li>\n<li>regenerates site if modifications detected</li>\n<li>caches previous regenerations, for faster iterations</li>\n<li>opens <code>index.html</code>, or <code>readme.html</code> in browser on startup</li>\n</ul>\n<p>Meaning, if you refresh the page in the browser, the local web-server will scan the source files for changes, recompile, and serve you the new <code>.html</code> page.</p>\n<h3>Debugging Coffeescript/SASS/Haml files</h3>\n<p>Because of the media processing, I use the <code>embellish</code> server to set-up my environment for debugging <code>.coffeescript</code>, <code>.sass</code> and <code>.haml</code> files.</p>\n<p>Just run the server over my directory:</p>\n<div class="codehilite"><pre>embellish -m .\n</pre></div>\n\n\n<p>Then edit the source files and refresh in the browser to compile. The server output in the terminal will show compilation errors. And the developer console is opened in the refreshed page, showing <code>console.log</code> messages from the javascript.</p>\n<h2>Templating guide</h2>\n<p>To write custom templates in <code>jinja2-haml</code>, you\'ll have to understand the data model <code>embellish</code> uses to compile templates.</p>\n<p>During compilation, two dictionaries are passed into every template:</p>\n<ol>\n<li>\n<p><code>site</code>: contains all the settings for the entire site. This includes all the source directories, site url, and is essentially, the information in the <code>site.yaml</code> <a href="#fig-config"></a> configuration file.</p>\n</li>\n<li>\n<p><code>page</code>: contains all the information of a given page, including <code>subpages</code> when the <code>page</code> is an index.</p>\n</li>\n</ol>\n<h3>Page Metadata</h3>\n<p>Every <code>page</code> dictionary comes equiped with a set of default metadata. The best way to show this is from the Python source code <a href="#fig-page-dictionary"></a>:</p>\n<div id="fig-page-dictionary"> <code>page</code> - the python dictionary that is piped into every template\n<pre class="codehilite">\npage = {\n  \'template\': \'default.haml\',  # name of template file\n  \'filename\': fname,  # name of markdown file\n  \'modified\': os.path.getmtime(fname),  # unix time number of file  \n  \'checksum\': \'\', # checksum used to check final output to avoid redundant writes\n  \'excerpt\': \'\', # text to put in excerpt, no tags please!\n  \'content\': \'\',  # main text of article\n  \'title\': \'\',  # title for indexing and for large display\n  \'category\': \'\',  # category of article for indexing \n  \'rel_site_url\': \'\',  # the top site directory relative to this page\n  \'date\': None,  # published date\n  \'slug\': None,  # url-safe name of article used to make url and files\n  \'url\': \'\',   # relative url used for links in index files\n  \'target\': \'\',    # target filename, maybe different to url due to redirection\n  \'index\': False,   # indicates if this is an indexing page\n  \'sort_key\': None,  # the field on which to sort under in indexing\n  \'sort_reverse\': True,  # ascending or descing order for sorting\n  \'subpages\': [],   # in indexing, pages belonging to the index placed here\n  \'max_subpages\': None,  # a maximum limit of files to put in subpages\n}\n</pre>\n</div>\n\n<p>This relevant fields in the <code>page</code> dictionary is then overriden by the YAML header of the corresponding source file. </p>\n<p>In a <code>jinja2-haml</code> template, these fields are accessible in the form of:</p>\n<div class="codehilite"><pre>{{ page.title }}\n</pre></div>\n\n\n<p>In particular, dates are converted to standard Python datetime objects, and can be passed into the jinja templates by calling the datetime string method:</p>\n<div class="codehilite"><pre>{{ page.date.strftime(&quot;%d %b %Y&quot;) }}\n</pre></div>\n\n\n<p>If excerpts are not given, <code>page.excerpt</code> is set to the first 50 non-tag words in the main text.</p>\n<h3>Filenames and Directory Structure</h3>\n<p>Two design principles of <code>embellish</code> is that it lets you determine the URL and file placement as much as possible, and that relative URLs should work. No matter what, <code>page.target</code> will contain the filename of the target HTML file, which is written in the <code>site.output_dir</code> directory. If <code>page.url</code> or <code>page.target</code> are specified, these will be used.</p>\n<p>Most of the time <code>page.url</code> will match <code>page.target</code>. If <code>page.url</code> is not specified, then it is assumed that the path of the markdown file with respect to the <code>site.content_dir</code> represents the <code>page.url</code> and the <code>page.target</code>. In flat-file mode, this means the <code>.html</code> file will appear in the same directory as the markdown file. </p>\n<p>A common exception to this are index.html files in subdirectories. Because browsers default to <code>dir/</code> for <code>dir/index.html</code>, a useful motif in the header for <code>index.html</code> files is:</p>\n<div class="codehilite"><pre>url: archive/\ntarget: archive/index.html\n</pre></div>\n\n\n<p>Two other fields need to be mentioned. Sometimes legitimate filenames cannot serve as URLs, so a conversion is done to turn the basename of the filename into a <code>page.slug</code>. This can be directly overriden if the <code>page.slug</code> field is given.</p>\n<p>Finally, the extension of the output files are normally assumed to be <code>.html</code> but this can be overriden in <code>site.ext</code> in the configuration file.</p>\n<h3>Absolute &amp; Relative URLs</h3>\n<p>To reiterate, the site\'s URL is given in:</p>\n<ol>\n<li>an absolute form {{ site.url }}</li>\n<li>a relative form, relative to the page {{ page.rel_site_url }}</li>\n</ol>\n<p>Where for instance if <code>embellish</code> was run in the current directory, and so is the file, then:</p>\n<div class="codehilite"><pre>page.rel_site_url = &#39;&#39;\n</pre></div>\n\n\n<p>The page\'s URL is thus a combination of the site URL and the page\'s relative URL:</p>\n<ol>\n<li>absolute: {{ site.url }}/{{ page.url }}</li>\n<li>relative {{ page.rel_site_url }}/{{ page.url }}</li>\n</ol>', 'sort_key': None, 'max_subpages': None, 'template': 'dark.haml', 'sort_reverse': True, 'date': datetime.datetime(2014, 2, 25, 0, 0), 'slug': u'index'}]