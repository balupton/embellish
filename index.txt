template: template.haml
---
---

# Embellish

A LOW-FRICTION WEBSITE GENERATOR



## Making Quick & Dirty Websites

Most Python website generators are highly opinionated.

This one is not.

Other generators dictate your directories to be structured their way. 

`embellish` can make a website out of any directory.

Go to a directory (e.g. the `embellish` directory)  with a `markdown` file (e.g. `readme.txt`):

	> embellish -m .

Boom! 

`readme.html` is generated and opened in a browser.

Now edit `readme.txt`, save, and refresh the browser.





## Installation

Have `python` and `pip`? Then:

	  > pip install embellish

Dependencies (which should have been installed by `pip`): 

- markdown
- pyyaml
- hamlpy
- jinja2
- jinja2\_hamlpy
- flask
- dateutil
- sassin




## Blog with Categories

Any litmus test for a static website generator is to make a blog. Here's a quick guide using `embellish` where `markdown` is used for the text, `YAML` for metadata, and `haml` to write the HTML.


`embellish` will recognize files with extensions `.txt`, `.md`, `.mkd` and `.markdown` as post/article pages.

### Article page

The structure of a content page has three sections, separated by `---`, such as this `example.txt` [](#fig-post):


<div id="fig-post"><code>example.mkd</code> - example of a Markdown Post
<pre class="codehilite">
title: The Title of this Great Post
template: template.haml
category: promotion
other: anything you want in YAML
---
Excerpt of post
---
# Great Post in Markdown

## Markdown Sub-headers!

This is the _body_ of the text 
written in markdown
</pre>
</div>

Both the header and the excerpt are optional. 

If only two sections are given, it is assumed that the first is the header.

If no excerpt is given, an excerpt is generated, made up of the first 50 non-tag words in the main text.

`embellish` reads the header as YAML metadata. There are a few fields used by `embellish` but you can add anything you want. This metadata will be made available to you in the template as a dictionary called `page`.

If no `template` is given, a default one is used that is located in the embllish directory under `defaults/default.haml`.


### Templates

Of course you want to make your own template for the HTML in your page. `embellish` uses the `jinja2-haml` format. This is called so because, it uses the `haml` format to represent the HTML, and uses `jinja2` to input the templating variables and control strucutres.

A simple template for a blog page is `template.haml` in [](#fig-template).

<div id="fig-template"> 
  <code>template.haml</code> - example of a simple HAML template to generate an article HTML
  <pre class="codehilite">
%head
  %link{rel:'stylesheet',href:'styles.css'}

%body
  %h1 
    {{ page.title }}
  %i 
    category: 
    {{ page.category }}; 
    published: 
    {{ page.date.strftime("%d %b %Y") }}

  {{ page.content }}
  </pre>
</div>

For more information, go to the Template Guide below.

Notice that there is a link to a style sheet `styles.css`, which you should make and include in the directory.

However, I strongly recommend you learn to write `.sass` style sheets, which `embellish` will happily compile into `.css` for you. For instance, here's a sample `styles.sass` [](#fig-sass):

<div id="fig-sass"> 
  <code>style.sass</code> - a SASS file to generate <code>style.css</code>
  <pre class="codehilite">
body
  background-color: #FFF
  font-family: Helvetica
  width: 700px
  margin: 0 auto
.nav
  a 
    display:inline
    padding-right: 1em
  a:link
    text-decoration: none
  </pre>
</div>

And now, we do:

    > embellish .

This will combine `example.txt` with `template.haml` to make `example.html`, and also convert `styles.sass` into `styles.css`.


### Index Pages

To really get the blog going, we need to build index pages and/or archives. 

To do this, we simply add some flags to the header in a text file `index.txt` [](#fig-index-mkd):

<div id="fig-index-mkd"> <code>index.mkd</code> - example of a markdown file that generates a blog index file
<pre class="codehilite">
    template: index.haml
    index: True
    sort_key: date
    sort_reverse: True
    title: My Blog Posts in Reverse Chronological Order
    ---
</pre>
</div>

The key field is `index` and if it's set to true, then an index of all posts will be pumped into the page when the template is compiled. 

Then we create the template file for the index `index.haml` [](#fig-index-haml):

<div id="fig-index-haml"> <code>index.haml</code> - example of a HAML template that generates the HTML code for an index markdown file
<pre class="codehilite">
    - for subpage in page.subpages:
      .excerpt
        %a{href:"{{ subpage.url }}"} {{ subpage.title }}
          {{ subpage.date.strftime("%d %b %Y ") }}
</pre>
</div>

The  metadata used to generate such pages are: `page.index`, `page.template`, `page.category`, `page.sort_key`, `page.sort_reverse`, `page.max_subpages`. 

The controlling variable is the `page.index`. If this is set to True, then a group of pages, `page.subpages`, will be generated. Essentially, `page.subpages` are a list of pages, that are not themselves index pages. 

Furthermore, only pages with the same `page.category` as the index page are collected with the number of pages capped to `page.max_subpages` if this is given. If `page.category` is empty ('') then pretty much the entire site will be put into `page.subpages` except of course for other index pages.

These pages will be sorted by the field given in `page.sort_key`, and this will be either sorted in ascending order, or if `page.sort_reverse` is True, it is sorted in descending order. The default is to sort by date, from most recent to oldest: `sort_key: date` and `sort_reverse: True`.

You can always populate your own sorting key, with headings, section, chapters, tags etc.

In your HAML/Jinja2 template, to make a list of items such as in an archive of posts, you simply loop through the `page.subpages` field. As there already exists  a `page` dictionary, don't use that variable name! Use `subpage` instead as your looping variable:


On pagination: sorry, but I hate pagination so I haven't implemented it here. My experience is that most blogs are not that big and don't have that many articles to archive. It would be so much easier to browse if all the posts were put in one page.


### URLs

Two design principles of `embellish` is that it lets you determine the URL and file placement as much as possible, and that relative URLs should work. No matter what, `page.target` will contain the filename of the target HTML file, which is written in the `site.output_dir` directory. If `page.url` or `page.target` are specified, these will be used.

Most of the time `page.url` will match `page.target`. If `page.url` is not specified, then it is assumed that the path of the markdown file with respect to the `site.content_dir` represents the `page.url` and the `page.target`. In flat-file mode, this means the `.html` file will appear in the same directory as the markdown file. 

A common exception to this are index.html files in subdirectories. Because browsers default to `dir/` for `dir/index.html`, a useful motif in the header for `index.html` files is:

    url: archive/
    target: archive/index.html


To use relative URLs in your templates is easy. Let's say in a `page`, you want to refer to the url of another page `subpage.url`. You then use the `page.rel_site_url` field to take you from `page` to the root directory of the site. Then to take you down to `subpage`, you use `subpage.url`:

    %a{href="{{ page.rel\_site\_url }}/{{ subpage.url }}"} relative link

If you don't care about relative directories, you can just use `subpage.url` from `/`:

    %a{href="/{{ subpage.url }}"} absolute link

And with the full url in case you are interacting with external javascript libraries:

    %a{href="{{ site.url }}/{{ subpage.url }}"} full url link

Two other fields need to be mentioned. Sometimes legitimate filenames cannot serve as URLs, so a conversion is done to turn the basename of the filename into a `page.slug`. This can be directly overriden if the `page.slug` field is given.

Finally, the extension of the output files are normally assumed to be `.html` but this can be overriden in `site.ext` in the configuration file.




## Larger Websites

### Configuration Files

Obviously for a more complicated website, you want to separate your content, templates, assets, and output into different directories.

To tell `embellish` where the directories are, you create a configuration file in the YAML format, such as `site.yaml` [](#fig-config):

<div id="fig-config"> <code>site.yaml</code> a YAML configuration file for a larger website
<pre class="codehilite">
url: http://boscoh.com # if empty then use relative urls
content_dir: content  # look for markdown files
template_dir: templates  # look for templates
output_dir: site  # generated files and static files put here
media_dir: media  # files to be correctly directly into the output file
ext: .html
</pre>
</div>

To whit:

- `url`: the hard-coded URL of your website. If given, this is available in any templates you make.
- `content_dir`: the directory where you put all your posts and index files.
- `template_dir`: put all templates here
- `media_dir`: your supporting files - javascript, css style sheets, images and movies
- `output_dir`: the directory where all compiled contents and contents of media_dir are put
- `ext`: the extension for the html files, typically `.html` or `.html`

To run `embellish` against this configuration file:

    embellish site.yaml

And the result will be in the `output_dir`.

When using `embellish` with a directory as the argument, such as:

     > embellish .

the directories - `content_dir`, `template_dir`, `media_dir`, `output_dir` - are implicitly set to that directory. The website is made in place!



### Recursive Directory Processing

Since `embellish` is meant to be a quick-and-dirty website generator, the default is to search only in the directory specified for content files. 

This avoids accidentally telling `embellish` to search through a very large forest of subdirectories.

But you can tell `embellish` to exhaustively process all subdirectories with the `-r` option:

    > embellish -r .



### A Bit of Media Processing

Now one useful thing that `embellish` does in copying over the `media_dir` files is to do some file processing. Currently the following files are automatically processed:

  - `.sass` files are compiled to `.css` style sheets
  - `.scss` files are compiled to `.css` style sheets
  - straight `.haml` with no template tags are compiled into `.html` files
  - `.coffee` files are compiled to `.js` javascript files

So potentially, your directory could just consist of `.haml` files and

    > embellish .

will make a nice website consisting of compiled `.html` files.

As will the directory structure of `media_dir` is replicated in the `output_dir`. Obviously, if they're the same, there is no copying, but files will be processed.



### Local Webserver to Debug Website

To iterate designs quickly, it's important you see the compiled websites easily. Like many other generators, `embellish` provides a local webserver to do this.

Why? 

Opening local `.html` pages through a browser is a crippled process. Browsers can't figure out `index.html` files from directory names and relative URL's get all messed up. On your actual server, these features are typically enabled in the Apache `.htaccess` file. 

Basically, if you test relative URLs, it's a nightmare. If you use test absolute URLs, it's also a nightmare.

To help with that, `embellish` has a local web-server written in `flask` to emulate common `.htaccess` features such as:

 - adding trailing `/` to directories
 - processing implied `index.html` in directories
 - adding implied `.html` to clean urls

To run the `embellish` local web-server:

    embellish -m .

Or if you have a configuration file:

    embellish -m site.yaml

As well the `embellish` server:

 - monitors modfications in directories 
 - regenerates site if modifications detected
 - opens `./index.html` in browser on startup

Meaning, if you refresh the page in the browser, the local web-server will scan the source files for changes, recompile, and serve you the new `.html` page.

The local web-server will pick a random port so that you can run different servers for different websites at the same time.




## Templating guide

`Embellish` is designed to help you play around with templates. In `embellish`, there's no need to define different types of posts. Simply set the `page.template` field to the template of your choice, and populate the correspoding metadata in your markdown files. `Embellish` is quite flexible in looking for template files. And as long as the metadata and the templates match, you're good to go.

### Metadata

In order to make awesome templates, you have to understand the metadata that are piped into them. During rendering, two dictionaries are passed into every template:

  - `page`: contains all the information of a given page. For instance, the content is found in `page.content`
  - `site`: contains all the settings for the entire site. This includes all the source directories, site url, and is essentially, the information in the `site.yaml` configuration file.

Every `page` dictionary comes equiped with a set of default metadata. The best way to show this is from the Python source code [](#fig-page-dictionary):

<div id="fig-page-dictionary"> <code>page</code> - the python dictionary that is piped into every template
<pre class="codehilite">
    page = {
      'template': 'default.haml',  # name of template file
      'filename': fname,  # name of markdown file
      'modified': os.path.getmtime(fname),  # unix time number of file  
      'checksum': '', # checksum used to check final output to avoid redundant writes
      'excerpt': '', # text to put in excerpt, no tags please!
      'content': '',  # main text of article
      'title': '',  # title for indexing and for large display
      'category': '',  # category of article for indexing 
      'rel_site_url': '',  # the top site directory relative to this page
      'date': None,  # published date
      'slug': None,  # url-safe name of article used to make url and files
      'url': '',   # relative url used for links in index files
      'target': '',    # target filename, maybe different to url due to redirection
      'index': False,   # indicates if this is an indexing page
      'sort_key': None,  # the field on which to sort under in indexing
      'sort_reverse': True,  # ascending or descing order for sorting
      'subpages': [],   # in indexing, pages belonging to the index placed here
      'max_subpages': None,  # a maximum limit of files to put in subpages
    }
</pre>
</div>

This relevant fields in the `page` dictionary is then overriden by the YAML header of the corresponding source file. 

In a HAML/Jinja2 template, these fields are accessible in the form of:

    {{ page.title }}

In particular, dates are converted to standard Python datetime objects, and can be passed into the jinja templates by calling the datetime string method:

    {{ page.date.strftime("%d %b %Y") }}

If excerpts are not given, `page.excerpt` is set to the first 50 non-tag words in the main text.




